---
phase: 11-configuration-ux
plan: 01
type: execute
---

<objective>
Create config module with OS-native paths and integrate into CLI argument resolution.

Purpose: Enable persistent configuration storage so users don't need to specify URL/API key every time.
Output: `src/config.rs` module with load/save functions, CLI falls back to config file when args not provided.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Current CLI structure:**
@src/bin/immich-dupes.rs

**Key patterns from current implementation:**
- Uses `clap` with `env` feature for `IMMICH_URL` and `IMMICH_API_KEY`
- Uses `dotenvy` to load `.env` files at startup
- Args are `Option<String>` with `.context()` error handling per-command

**Discovery findings:**
- `directories` crate v5.0: Use `ProjectDirs::from("", "", "immich-dupes")` for OS-native paths
  - macOS: `~/Library/Application Support/immich-dupes/`
  - Linux: `~/.config/immich-dupes/`
  - Windows: `C:\Users\<user>\AppData\Roaming\immich-dupes\`
- Use TOML format for human-readable config (already have `serde` dependency)

**Config file location:**
`{config_dir}/config.toml`

**Config structure:**
```toml
[server]
url = "https://immich.example.com"
api_key = "your-api-key"
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies for config support</name>
  <files>Cargo.toml</files>
  <action>
Add two dependencies:
- `directories = "5"` - for OS-native config paths
- `toml = "0.8"` - for config file parsing (human-readable format)

Place in the "Binary dependencies" section since config is only used by the binary.
  </action>
  <verify>`cargo check` succeeds</verify>
  <done>Both dependencies added to Cargo.toml, project compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create config module with load/save functions</name>
  <files>src/bin/config.rs</files>
  <action>
Create new module `src/bin/config.rs` with:

1. **Config struct** (derives Serialize, Deserialize, Default, Clone):
```rust
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Config {
    #[serde(default)]
    pub server: ServerConfig,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ServerConfig {
    pub url: Option<String>,
    pub api_key: Option<String>,
}
```

2. **config_path() function**: Returns `PathBuf` to config file
   - Use `directories::ProjectDirs::from("", "", "immich-dupes")`
   - Return `{config_dir}/config.toml`
   - If ProjectDirs fails (rare), fall back to `~/.config/immich-dupes/config.toml`

3. **load() function**: Returns `Config`
   - If config file exists, parse TOML and return
   - If file doesn't exist or parse fails, return `Config::default()`
   - Use `?` operator internally, catch errors at call site
   - Log debug message if config loaded vs defaults

4. **save(config: &Config) function**: Returns `Result<(), anyhow::Error>`
   - Create parent directories if needed (`std::fs::create_dir_all`)
   - Serialize to TOML with `toml::to_string_pretty`
   - Write atomically (write to temp, then rename) to prevent corruption
   - Return error if write fails

Do NOT use `.unwrap()` or `.expect()` - use `?` operator and proper error handling.
  </action>
  <verify>`cargo check` succeeds, `cargo clippy -- -D warnings` passes</verify>
  <done>Config module compiles with load/save functions, no clippy warnings</done>
</task>

<task type="auto">
  <name>Task 3: Integrate config into CLI argument resolution</name>
  <files>src/bin/immich-dupes.rs</files>
  <action>
1. Add `mod config;` at top of file

2. In `main()`, after `dotenvy::dotenv()`:
   - Load config: `let config = config::load();`

3. Create helper function to resolve credentials:
```rust
fn resolve_credentials(
    cli_url: Option<&str>,
    cli_api_key: Option<&str>,
    config: &config::Config,
) -> (Option<String>, Option<String>) {
    // Priority: CLI args > env vars (handled by clap) > config file
    let url = cli_url
        .map(String::from)
        .or_else(|| config.server.url.clone());
    let api_key = cli_api_key
        .map(String::from)
        .or_else(|| config.server.api_key.clone());
    (url, api_key)
}
```

4. Update command handlers to use resolved credentials:
   - Call `resolve_credentials(args.url.as_deref(), args.api_key.as_deref(), &config)`
   - Use resolved values instead of raw `args.url` / `args.api_key`

5. Keep existing error messages using `.context()` - they'll fire if neither CLI, env, nor config provides values

The resolution order is: CLI args > env vars (clap handles) > config file > error
  </action>
  <verify>
- `cargo clippy -- -D warnings` passes
- `cargo build --release` succeeds
- Run `./target/release/immich-dupes analyze -o /tmp/test.json` without args - should error with "IMMICH_URL is required"
- Create config manually, verify it gets picked up (will test in 11-02)
  </verify>
  <done>CLI loads config file and uses values when CLI args not provided, clippy clean</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo clippy -- -D warnings` passes
- [ ] `cargo build --release` succeeds
- [ ] `cargo test` passes (existing tests still work)
- [ ] Config module exists at `src/bin/config.rs`
- [ ] Config loads from OS-native path
</verification>

<success_criteria>
- Config module created with load/save functions
- CLI integrates config loading
- Credential resolution: CLI > env > config > error
- No clippy warnings
- Existing functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/11-configuration-ux/11-01-SUMMARY.md`
</output>
