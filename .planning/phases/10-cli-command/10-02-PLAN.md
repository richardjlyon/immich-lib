---
phase: 10-cli-command
plan: 02
type: execute
---

<objective>
Implement `letterbox execute` CLI subcommand with backup-before-delete workflow.

Purpose: Safely remove 16:9 crop duplicates after downloading backups.
Output: Execute command that downloads 16:9 files to backup directory, then deletes them from Immich.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-cli-command/10-01-SUMMARY.md
@src/bin/immich-dupes.rs
@src/letterbox.rs
@src/executor.rs

**Prior decisions affecting this phase:**
- Phase 05-02: Two-phase download-then-delete pattern (only delete successfully backed up)
- Phase 05-02: Asset ID prefix in filenames prevents collision
- Phase 05-02: governor GCRA for rate limiting
- Letterbox has NO consolidation (unlike duplicates) - simpler workflow

**Patterns to follow:**
- Same confirmation prompt pattern as existing execute
- Same rate limiting approach (governor crate)
- Same backup filename format: `{asset_id_prefix}_{original_filename}`
- Same execution report output to backup directory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add letterbox execute subcommand</name>
  <files>src/bin/immich-dupes.rs</files>
  <action>
Add `Execute` variant to `LetterboxCommands`:

```rust
/// Execute letterbox removal: download 16:9 backups then delete
Execute {
    /// Path to letterbox analysis JSON from analyze command
    #[arg(short, long)]
    input: PathBuf,

    /// Directory to download backup files to
    #[arg(short, long)]
    backup_dir: PathBuf,

    /// Permanently delete instead of moving to trash
    #[arg(long, default_value = "false")]
    force: bool,

    /// Max requests per second (default: 10)
    #[arg(long, default_value = "10")]
    rate_limit: u32,

    /// Skip confirmation prompt
    #[arg(short, long, default_value = "false")]
    yes: bool,
},
```

Add match arm in the Letterbox command handler to call `run_letterbox_execute()`.

Import `LetterboxAnalysis` from `immich_lib::letterbox`.
  </action>
  <verify>
cargo clippy -- -D warnings passes
./target/release/immich-dupes letterbox execute --help shows all options
  </verify>
  <done>
Execute subcommand added to LetterboxCommands enum with proper CLI arguments
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement letterbox execute logic</name>
  <files>src/bin/immich-dupes.rs</files>
  <action>
Create `LetterboxExecutionReport` struct:

```rust
#[derive(Debug, Serialize)]
struct LetterboxExecutionReport {
    executed_at: DateTime<Utc>,
    server_url: String,
    total_pairs: usize,
    downloaded: usize,
    deleted: usize,
    failed: usize,
    skipped: usize,
    results: Vec<LetterboxPairResult>,
}

#[derive(Debug, Serialize)]
struct LetterboxPairResult {
    timestamp: String,
    keeper_id: String,
    delete_id: String,
    download_status: String,  // "success", "failed", "skipped"
    delete_status: String,    // "deleted", "trashed", "failed", "skipped"
    error: Option<String>,
}
```

Implement `run_letterbox_execute()`:

1. Read and parse LetterboxAnalysis from input JSON
2. Create backup directory if needed
3. Print execution summary:
   - Pairs to process
   - Estimated disk space (sum of delete file sizes)
   - Backup directory path
   - Force delete: yes/no

4. Confirmation prompt (unless --yes):
   ```
   About to download N files and delete them from Immich. Continue? [y/N]
   ```

5. Create ImmichClient
6. Set up rate limiter: `governor::RateLimiter` with GCRA, rate_limit requests/sec
7. For each pair:
   a. Rate limit wait
   b. Download delete target to backup_dir:
      - Filename: `{first_8_chars_of_id}_{original_filename}`
      - Use client.download_asset()
   c. If download succeeds, delete asset:
      - Use client.delete_assets() with force flag
   d. Track result in LetterboxPairResult

8. Print summary:
   ```
   Letterbox Execution Complete
   ============================
   Pairs processed: N
   Files downloaded: N
   Files deleted: N
   Failed: N
   Skipped: N
   ```

9. Write execution report JSON to backup_dir/letterbox-execution-{timestamp}.json

Note: No consolidation step needed for letterbox (unlike duplicates).
The 4:3 keeper already has all the metadata we need.
  </action>
  <verify>
cargo clippy -- -D warnings passes
cargo build --release succeeds
cargo test passes
  </verify>
  <done>
`letterbox execute` downloads 16:9 backups before deletion, writes execution report, handles errors gracefully
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo clippy -- -D warnings` passes with no warnings
- [ ] `cargo build --release` succeeds
- [ ] `cargo test` passes (existing tests still work)
- [ ] `./target/release/immich-dupes letterbox execute --help` shows all options
- [ ] Execute requires --input and --backup-dir arguments
- [ ] Confirmation prompt appears unless --yes flag used
</verification>

<success_criteria>
- `letterbox execute` command implemented with backup-before-delete workflow
- Rate limiting prevents API overload
- Execution report written to backup directory
- Failed downloads skip deletion (no data loss)
- All clippy warnings resolved
- Phase 10 complete - full letterbox workflow available
</success_criteria>

<output>
After completion, create `.planning/phases/10-cli-command/10-02-SUMMARY.md`

Final summary should note:
- Phase 10 complete
- Full letterbox workflow: analyze → execute → verify
- Existing restore command works for letterbox backups (generic)
- Ready for production use
</output>
