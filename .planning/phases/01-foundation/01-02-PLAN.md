---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Build the ImmichClient HTTP wrapper with API key authentication and verify connectivity against a real Immich instance.

Purpose: Complete the foundation phase by proving the client can authenticate and retrieve data.
Output: Working ImmichClient that can fetch duplicate groups from Immich API.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**From RESEARCH.md - Authentication:**
- Use `x-api-key` header with API key value
- API keys created in Immich web UI under user settings
- Required permissions: duplicate.read, asset.read

**From RESEARCH.md - Key Endpoint:**
```
GET /api/duplicates
Response: DuplicateResponseDto[]
```

**From RESEARCH.md - Client Pattern:**
```rust
pub struct ImmichClient {
    client: reqwest::Client,
    base_url: Url,
}

impl ImmichClient {
    pub fn new(base_url: &str, api_key: &str) -> Result<Self, Error>
    pub async fn get_duplicates(&self) -> Result<Vec<DuplicateGroup>, Error>
}
```

**From RESEARCH.md - Pitfalls to avoid:**
- Don't hardcode timeouts - make configurable
- Use url::Url type for URL manipulation, not string concatenation
- Handle non-success status codes explicitly
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build ImmichClient with authentication</name>
  <files>src/client.rs, src/lib.rs</files>
  <action>
Create src/client.rs with ImmichClient struct:

**ImmichClient struct:**
- client: reqwest::Client (with default headers set)
- base_url: url::Url

**ImmichClient::new(base_url: &str, api_key: &str) -> Result<Self>:**
- Parse base_url with url::Url::parse(), return ImmichError::Url on failure
- Validate api_key is non-empty, return ImmichError::InvalidApiKey if empty
- Build reqwest::Client with:
  - Default header: "x-api-key" = api_key
  - Timeout: 30 seconds (reasonable default)
- Return Ok(Self { client, base_url })

**ImmichClient::get_duplicates(&self) -> Result<Vec<DuplicateGroup>>:**
- Build URL: self.base_url.join("/api/duplicates")
- Send GET request with self.client
- Handle response:
  - If success (2xx): deserialize JSON to Vec<DuplicateGroup>
  - If error: extract status code and body text, return ImmichError::Api

**Private helper method handle_response<T: DeserializeOwned>:**
- Check response.status().is_success()
- On success: response.json::<T>().await
- On error: build ImmichError::Api with status and body

Update src/lib.rs:
- Add `mod client;`
- Re-export `pub use client::ImmichClient;`

Use async/await throughout. All errors should propagate with `?` operator.
  </action>
  <verify>cargo build compiles without errors</verify>
  <done>ImmichClient exists with new() and get_duplicates() methods, re-exported from lib.rs</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>ImmichClient with API key authentication and get_duplicates() method</what-built>
  <how-to-verify>
Test the client against your real Immich instance:

1. Get your Immich API key:
   - Open Immich web UI
   - Go to User Settings > API Keys
   - Create a new key (or use existing)

2. Create a test file `examples/test_connection.rs`:
```rust
use immich_lib::ImmichClient;
use std::env;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenvy::dotenv().ok();  // Load .env file

    let base_url = env::var("IMMICH_URL")
        .expect("IMMICH_URL must be set in .env");
    let api_key = env::var("API_KEY")
        .expect("API_KEY must be set in .env");

    let client = ImmichClient::new(&base_url, &api_key)?;

    let duplicates = client.get_duplicates().await?;
    println!("Found {} duplicate groups", duplicates.len());

    if let Some(first) = duplicates.first() {
        println!("First group has {} assets", first.assets.len());
    }

    Ok(())
}
```

**Before running:** Ensure your `.env` file contains:
```
IMMICH_URL=https://your-immich-server.com
API_KEY=your-api-key-here
```

3. Add to Cargo.toml under [[example]]:
```toml
[[example]]
name = "test_connection"
```

4. Run: `cargo run --example test_connection`

5. Expected output:
   - "Found N duplicate groups" (where N >= 0)
   - No authentication errors
   - No JSON parsing errors

**If you have no duplicates**, the test should still succeed with "Found 0 duplicate groups".
  </how-to-verify>
  <resume-signal>Type "approved" if connection works and duplicates are fetched, or describe any errors encountered</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo doc --no-deps` includes ImmichClient documentation
- [ ] Connection test passes against real Immich instance
- [ ] API key authentication works (no 401 errors)
- [ ] JSON deserialization works (duplicates parsed correctly)
</verification>

<success_criteria>
- All tasks completed
- Human verified: Client connects to real Immich instance
- Human verified: get_duplicates() returns valid data (even if empty)
- No authentication or parsing errors
- Phase 1: Foundation complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`:

# Phase 1 Plan 02: HTTP Client & Authentication Summary

**[One-liner: e.g., "ImmichClient authenticates and fetches duplicate groups from Immich API"]**

## Accomplishments
- ImmichClient with API key authentication
- get_duplicates() method working
- Verified against real Immich instance

## Files Created/Modified
- `src/client.rs` - HTTP client implementation
- `src/lib.rs` - Re-exports
- `examples/test_connection.rs` - Connection test

## Decisions Made
[Any deviations, timeout values chosen, etc.]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 1 complete. Ready for Phase 2: Duplicate Discovery.
</output>
