---
phase: 05-execution-stage
plan: 02
type: execute
---

<objective>
Build the executor module with rate-limited concurrent operations.

Purpose: Implement the execution pipeline that consolidates metadata, downloads backups, and deletes duplicates with proper rate limiting and progress reporting.
Output: New `executor.rs` module with `Executor` struct and execution pipeline, plus supporting types in `models/execution.rs`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-execution-stage/05-RESEARCH.md
@.planning/phases/05-execution-stage/05-01-SUMMARY.md

**Prior decisions affecting this phase:**
- DuplicateAnalysis struct has winner/losers with asset_id and filename (Phase 03-01)
- AnalysisReport has groups Vec<DuplicateAnalysis> (Phase 04-01)

**Research findings to apply:**
- Use `governor` for rate limiting (GCRA algorithm)
- Use `tokio::sync::Semaphore` for concurrency control
- Use `indicatif` for progress bars
- Default: 10 req/sec, 5 concurrent (configurable)
- Include asset ID in download filename to avoid collisions
- Two-phase: download ALL first, then delete only successfully downloaded
- Graceful partial failure handling - continue on individual failures

**Don't hand-roll:**
- Rate limiting (use governor)
- Progress bars (use indicatif)
- Concurrency control (use Semaphore)

@src/client.rs
@src/scoring.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add executor dependencies and types</name>
  <files>Cargo.toml, src/models/execution.rs, src/models/mod.rs, src/lib.rs</files>
  <action>
1. Add dependencies to Cargo.toml:
   - `governor = "0.6"`
   - `indicatif = "0.17"`
   - `nonzero_ext = "0.3"` (for governor Quota literals)

2. Create src/models/execution.rs with types:
   - `ExecutionConfig`: requests_per_sec (u32), max_concurrent (usize), backup_dir (PathBuf), force_delete (bool)
   - `OperationResult` enum: Success { id, path }, Failed { id, error }, Skipped { id, reason }
   - `ExecutionReport`: total_groups, downloaded, deleted, failed, skipped, results Vec<GroupResult>
   - `GroupResult`: duplicate_id, winner_id, consolidation_result, download_results, delete_result

3. Export from models/mod.rs and lib.rs
4. Derive Debug, Clone, Serialize as appropriate
  </action>
  <verify>cargo build --lib succeeds</verify>
  <done>Execution types defined and exported, dependencies added</done>
</task>

<task type="auto">
  <name>Task 2: Create Executor struct with rate limiting</name>
  <files>src/executor.rs, src/lib.rs</files>
  <action>
Create src/executor.rs with Executor struct:

1. Struct fields:
   - client: ImmichClient
   - rate_limiter: RateLimiter (governor direct rate limiter)
   - concurrency: Arc<Semaphore>
   - config: ExecutionConfig

2. Constructor `Executor::new(client, config)`:
   - Create rate limiter with Quota::per_second(nonzero!(config.requests_per_sec))
   - Create semaphore with config.max_concurrent permits

3. Helper method `async fn rate_limited<F, T>(&self, op: F) -> Result<T>`:
   - Wait for rate limit: `self.rate_limiter.until_ready().await`
   - Acquire semaphore permit
   - Execute operation
   - This pattern used by download/delete methods

4. Add `pub mod executor;` to lib.rs and export Executor

Use imports:
- `governor::{Quota, RateLimiter, clock::DefaultClock, state::{InMemoryState, NotKeyed}}`
- `tokio::sync::Semaphore`
- `nonzero_ext::nonzero`
  </action>
  <verify>cargo build --lib succeeds</verify>
  <done>Executor struct with rate limiting infrastructure compiles</done>
</task>

<task type="auto">
  <name>Task 3: Implement execution pipeline methods</name>
  <files>src/executor.rs</files>
  <action>
Add execution methods to Executor:

1. `pub async fn execute_group(&self, analysis: &DuplicateAnalysis, pb: &ProgressBar) -> GroupResult`:
   - Consolidate metadata: copy GPS/description from losers to winner if winner lacks them
   - Download each loser to backup_dir/{asset_id}_{filename}
   - Track download results
   - Only delete successfully downloaded assets
   - Return GroupResult with all outcomes

2. `pub async fn execute_all(&self, groups: &[DuplicateAnalysis]) -> ExecutionReport`:
   - Create MultiProgress with overall progress bar
   - Iterate through groups, calling execute_group
   - Update progress bar after each group
   - Collect all results into ExecutionReport
   - Handle individual failures gracefully (continue processing)

3. Helper `async fn consolidate_metadata(&self, winner: &ScoredAsset, losers: &[ScoredAsset], assets: &[AssetResponse]) -> Option<String>`:
   - Check if winner lacks GPS but any loser has it
   - Check if winner lacks description but any loser has it
   - Call client.update_asset_metadata if consolidation needed
   - Return consolidation description or None

4. Helper `async fn download_loser(&self, loser: &ScoredAsset) -> OperationResult`:
   - Build path: backup_dir / {asset_id}_{filename}
   - Call client.download_asset
   - Return Success or Failed

Note: For consolidation, we need the original AssetResponse to check EXIF. The analysis only has ScoredAsset. Two options:
- Option A: Add exif fields to ScoredAsset during analysis
- Option B: Skip consolidation for now, document as future enhancement

Choose Option B for this plan - consolidation requires re-fetching asset data. Add TODO comment.
  </action>
  <verify>cargo clippy -- -D warnings passes</verify>
  <done>Executor can execute groups with download/delete, graceful failure handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --lib` succeeds
- [ ] `cargo clippy -- -D warnings` passes
- [ ] `cargo test` passes
- [ ] Executor struct has execute_all and execute_group methods
- [ ] Rate limiting uses governor crate
- [ ] Concurrency uses tokio Semaphore
- [ ] Progress uses indicatif ProgressBar
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Executor module compiles and exports from lib.rs
- Rate-limited concurrent execution implemented
- Graceful partial failure handling (continues on individual failures)
- Ready for CLI integration in Plan 3
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-stage/05-02-SUMMARY.md`:

# Phase 5 Plan 2: Executor Module Summary

**[One-liner describing what was built]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `Cargo.toml` - Added governor, indicatif, nonzero_ext
- `src/executor.rs` - New executor module
- `src/models/execution.rs` - Execution types
- `src/models/mod.rs` - Export execution types
- `src/lib.rs` - Export executor module

## Decisions Made
[Key decisions and rationale]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 05-03-PLAN.md (Execute CLI Command)
</output>
