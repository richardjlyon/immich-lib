---
phase: 09-detection
plan: 02
type: execute
---

<objective>
Build the letterbox analysis report and integrate with ImmichClient for fetching iPhone assets.

Purpose: Enable CLI to analyze an Immich instance for letterbox pairs and output reviewable JSON.
Output: LetterboxAnalysis report type, ImmichClient method for iPhone asset search.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-research/DISCOVERY.md
@.planning/phases/09-detection/09-01-SUMMARY.md

**Prior decisions affecting this phase:**
- Reuse existing analyze → JSON → execute workflow (Phase 8)
- Same rate limiting and error handling (Phase 8)
- Track processed pairs by asset ID (Phase 8)

**Existing patterns to follow:**
@src/scoring.rs - DuplicateAnalysis, AnalysisReport patterns
@src/client.rs - ImmichClient API methods
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LetterboxAnalysis report type</name>
  <files>src/letterbox.rs</files>
  <action>
Add analysis report types following DuplicateAnalysis pattern:

1. LetterboxAnalysis struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LetterboxAnalysis {
    pub pairs: Vec<LetterboxPair>,
    pub total_pairs: usize,
    pub total_space_recoverable: u64,  // Sum of delete asset sizes
    pub skipped_ambiguous: usize,      // Groups with multiple pairs at same timestamp
    pub skipped_non_iphone: usize,     // Non-Apple assets encountered
    pub analyzed_at: String,           // ISO 8601 timestamp
}
```

2. Builder function:
```rust
impl LetterboxAnalysis {
    pub fn from_assets(assets: &[AssetResponse]) -> Self
}
```
- Call find_letterbox_pairs internally
- Calculate space recoverable from delete assets' file_size_in_byte
- Track skip counts for reporting
- Set analyzed_at to current UTC time

3. Add Deserialize to LetterboxPair for JSON round-trip.

Avoid: Coupling to CLI output format - keep as pure data structure.
  </action>
  <verify>cargo clippy -- -D warnings && cargo test letterbox</verify>
  <done>LetterboxAnalysis serializes to JSON matching existing report patterns</done>
</task>

<task type="auto">
  <name>Task 2: Add ImmichClient method for fetching all assets</name>
  <files>src/client.rs</files>
  <action>
Add method to fetch all assets (needed for letterbox scanning):

1. New method:
```rust
impl ImmichClient {
    /// Fetches all assets from the Immich server.
    /// Uses pagination to handle large libraries.
    pub async fn get_all_assets(&self) -> Result<Vec<AssetResponse>>
}
```

2. Implementation:
- Use `/api/assets` endpoint with pagination
- Query params: `take=1000` (page size), `skip=N` (offset)
- Loop until response is empty
- Filter out trashed assets (is_trashed = true)
- Use existing rate limiting if applicable

3. Alternative: Add search method if Immich has asset search API:
```rust
pub async fn search_assets(&self, make: Option<&str>, model: Option<&str>) -> Result<Vec<AssetResponse>>
```
- Would be more efficient for iPhone-only filtering
- Check if /api/search/metadata endpoint exists

Avoid: Loading all assets into memory at once for huge libraries - but acceptable for MVP since we need to group them anyway.
  </action>
  <verify>cargo clippy -- -D warnings && cargo build</verify>
  <done>get_all_assets method works with pagination, tested against mock or real API</done>
</task>

<task type="auto">
  <name>Task 3: Add integration and export updates</name>
  <files>src/letterbox.rs, src/lib.rs</files>
  <action>
1. Update lib.rs exports:
```rust
pub mod letterbox;
pub use letterbox::{AspectRatio, LetterboxPair, LetterboxAnalysis, detect_aspect_ratio, find_letterbox_pairs};
```

2. Add convenience method to LetterboxAnalysis:
```rust
impl LetterboxAnalysis {
    /// Returns asset IDs of all assets marked for deletion
    pub fn delete_ids(&self) -> Vec<&str> {
        self.pairs.iter().map(|p| p.delete.id.as_str()).collect()
    }

    /// Returns asset IDs of all keepers
    pub fn keeper_ids(&self) -> Vec<&str> {
        self.pairs.iter().map(|p| p.keeper.id.as_str()).collect()
    }
}
```

3. Add integration test:
- Create mock assets with realistic EXIF data
- Run LetterboxAnalysis::from_assets
- Verify pairs found, space calculated, JSON serializable

Avoid: Adding CLI command here - that's Phase 10.
  </action>
  <verify>cargo clippy -- -D warnings && cargo test && cargo doc --no-deps</verify>
  <done>letterbox module fully integrated, public API documented, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo clippy -- -D warnings` passes
- [ ] `cargo test` passes all tests (including new integration tests)
- [ ] `cargo doc --no-deps` generates documentation without warnings
- [ ] `cargo build --release` succeeds
- [ ] LetterboxAnalysis can serialize to/from JSON
</verification>

<success_criteria>
- LetterboxAnalysis report type matches existing patterns
- get_all_assets fetches paginated assets from Immich
- Public API exported from lib.rs
- Integration test validates end-to-end flow
- Phase 9 complete, ready for Phase 10 CLI command
</success_criteria>

<output>
After completion, create `.planning/phases/09-detection/09-02-SUMMARY.md`

Include in summary:
- Note that Phase 9 complete
- Ready for Phase 10: CLI `letterbox` command
</output>
